let target_upn = "rfleming@1800flowers.com";
let TimeWindow = 3h;
let TimeWindowMinutes = toint(TimeWindow / 1m);
let Lookback = 3d;
// Trusted IP ranges
let TrustedCIDRs = toscalar(
    _GetWatchlist('trustedcidr')
    | where isnotempty(SearchKey)
    | summarize make_list(SearchKey)
);
// Azure IPs (only east regions)
let AzureCIDRs = toscalar(
    _GetWatchlist('azureip')
    | where tolower(Region) has_any ("eastus", "eastus2")
    | summarize make_list(IP_CIDR)
);
// SigninLogs with geo
let SigninsA = SigninLogs
| where TimeGenerated > ago(Lookback)
| where isnotempty(UserPrincipalName) and isnotempty(IPAddress)
| extend Type = "SigninLogs"
| extend User = tostring(UserPrincipalName),
         IP = tostring(IPAddress),
         City = tostring(LocationDetails["city"]),
         Country = tostring(LocationDetails["countryOrRegion"]),
         Latitude = toreal(LocationDetails["geoCoordinates"]["latitude"]),
         Longitude = toreal(LocationDetails["geoCoordinates"]["longitude"])
| where not(ipv4_is_in_any_range(IP, AzureCIDRs))
| project User, IP, City, Country, Latitude, Longitude, TimeGenerated, SourceType = Type;
// CloudAppEvents without geo
let SigninsB = CloudAppEvents
| where TimeGenerated > ago(Lookback)
| where isnotempty(AccountDisplayName) and isnotempty(IPAddress)
| extend Type = "CloudAppEvents"
| extend User = tostring(AccountDisplayName),
         IP = tostring(IPAddress),
         City = tostring(City),
         Country = tostring(CountryCode),
         Latitude = real(null),
         Longitude = real(null)
| where not(ipv4_is_in_any_range(IP, AzureCIDRs))
| project User, IP, City, Country, Latitude, Longitude, TimeGenerated, SourceType = Type;
// Combine and filter
let Signins = union SigninsA, SigninsB
| where not(ipv4_is_in_any_range(IP, TrustedCIDRs))
| where isnotempty(User) and isnotempty(City) and isnotempty(Country)
| where User !contains "Rubrik"
| where User == target_upn;
// Join and compare sign-ins
Signins
| join kind=inner hint.shufflekey=User (
    Signins
) on User
| where TimeGenerated < TimeGenerated1
    and abs(datetime_diff("minute", TimeGenerated, TimeGenerated1)) <= TimeWindowMinutes
    and (City != City1 or Country != Country1)
// Extend #1: Rad values and time difference
| extend
    TimeDiffHours = datetime_diff("second", TimeGenerated1, TimeGenerated) / 3600.0,
    Lat1Rad = Latitude * (3.14159265358979 / 180.0),
    Lat2Rad = Latitude1 * (3.14159265358979 / 180.0),
    DeltaLatRad = (Latitude1 - Latitude) * (3.14159265358979 / 180.0),
    DeltaLonRad = (Longitude1 - Longitude) * (3.14159265358979 / 180.0)
// Extend #2: Haversine A
| extend
    HaversineA = sin(DeltaLatRad / 2.0) * sin(DeltaLatRad / 2.0) +
                 cos(Lat1Rad) * cos(Lat2Rad) *
                 sin(DeltaLonRad / 2.0) * sin(DeltaLonRad / 2.0)
// Extend #3: Haversine C
| extend
    HaversineC = 2.0 * atan2(sqrt(HaversineA), sqrt(1.0 - HaversineA))
// Extend #4: Distance in KM and Miles
| extend
    DistanceKM = iif(isnotnull(HaversineC), 6371.0 * HaversineC, real(null)),
    DistanceMI = iif(isnotnull(HaversineC), 3958.8 * HaversineC, real(null))  // Earth radius in miles
// Extend #5: Speed using Distance
| extend
    SpeedKPH = iif(DistanceKM > 0 and TimeDiffHours > 0, DistanceKM / TimeDiffHours, real(null)),
    SpeedMPH = iif(DistanceMI > 0 and TimeDiffHours > 0, DistanceMI / TimeDiffHours, real(null))
// Final output
| project
    User,
    FirstSigninTime = TimeGenerated,
    FirstCity = City,
    FirstCountry = Country,
    FirstIP = IP,
    FirstSource = SourceType,
    FirstLatitude = Latitude,
    FirstLongitude = Longitude,
    SecondSigninTime = TimeGenerated1,
    SecondCity = City1,
    SecondCountry = Country1,
    SecondIP = IP1,
    SecondSource = SourceType1,
    SecondLatitude = Latitude1,
    SecondLongitude = Longitude1,
    TimeDiffHours,
    DistanceKM,
    DistanceMI,
    SpeedKPH,
    SpeedMPH
// Uncomment to only return high-speed logins
// | where SpeedMPH > 500
| order by FirstSigninTime desc






{
  "query": "let target_upn = \"rfleming@1800flowers.com\";\nlet TimeWindow = 3h;\nlet TimeWindowMinutes = toint(TimeWindow / 1m);\nlet Lookback = 7d;\n\n// Trusted IP ranges\nlet TrustedCIDRs = toscalar(\n    _GetWatchlist('trustedcidr')\n    | where isnotempty(SearchKey)\n    | summarize make_list(SearchKey)\n);\n\n// Azure IPs (only east regions)\nlet AzureCIDRs = toscalar(\n    _GetWatchlist('azureip')\n    | where tolower(Region) has_any (\"eastus\", \"eastus\")\n    | summarize make_list(IP_CIDR)\n);\n\n// SigninLogs with geo\nlet SigninsA = SigninLogs\n| where TimeGenerated > ago(Lookback)\n| where isnotempty(UserPrincipalName) and isnotempty(IPAddress)\n| extend Type = \"SigninLogs\"\n| extend User = tostring(UserPrincipalName),\n         IP = tostring(IPAddress),\n         City = tostring(LocationDetails[\"city\"]),\n         Country = tostring(LocationDetails[\"countryOrRegion\"]),\n         Latitude = toreal(LocationDetails[\"geoCoordinates\"][\"latitude\"]),\n         Longitude = toreal(LocationDetails[\"geoCoordinates\"][\"longitude\"])\n| where not(ipv4_is_in_any_range(IP, AzureCIDRs))\n| project User, IP, City, Country, Latitude, Longitude, TimeGenerated, SourceType = Type;\n\n// CloudAppEvents without geo\nlet SigninsB = CloudAppEvents\n| where TimeGenerated > ago(Lookback)\n| where isnotempty(AccountDisplayName) and isnotempty(IPAddress)\n| extend Type = \"CloudAppEvents\"\n| extend User = tostring(AccountDisplayName),\n         IP = tostring(IPAddress),\n         City = tostring(City),\n         Country = tostring(CountryCode),\n         Latitude = real(null),\n         Longitude = real(null)\n| where not(ipv4_is_in_any_range(IP, AzureCIDRs))\n| project User, IP, City, Country, Latitude, Longitude, TimeGenerated, SourceType = Type;\n\n// Combine and filter\nlet Signins = union SigninsA, SigninsB\n| where not(ipv4_is_in_any_range(IP, TrustedCIDRs))\n| where isnotempty(User) and isnotempty(City) and isnotempty(Country)\n| where User !contains \"Rubrik\"\n| where User == target_upn;\n\n// Join and compare sign-ins\nSignins\n| join kind=inner hint.shufflekey=User (\n    Signins\n) on User\n| where TimeGenerated < TimeGenerated1\n    and abs(datetime_diff(\"minute\", TimeGenerated, TimeGenerated1)) <= TimeWindowMinutes\n    and (City != City1 or Country != Country1)\n\n// Extend #1: Rad values and time difference\n| extend\n    TimeDiffHours = datetime_diff(\"second\", TimeGenerated1, TimeGenerated) / 3600.0,\n    Lat1Rad = Latitude * (3.14159265358979 / 180.0),\n    Lat2Rad = Latitude1 * (3.14159265358979 / 180.0),\n    DeltaLatRad = (Latitude1 - Latitude) * (3.14159265358979 / 180.0),\n    DeltaLonRad = (Longitude1 - Longitude) * (3.14159265358979 / 180.0)\n\n// Extend #2: Haversine A\n| extend\n    HaversineA = sin(DeltaLatRad / 2.0) * sin(DeltaLatRad / 2.0) +\n                 cos(Lat1Rad) * cos(Lat2Rad) *\n                 sin(DeltaLonRad / 2.0) * sin(DeltaLonRad / 2.0)\n\n// Extend #3: Haversine C\n| extend\n    HaversineC = 2.0 * atan2(sqrt(HaversineA), sqrt(1.0 - HaversineA))\n\n// Extend #4: Distance in KM and Miles\n| extend\n    DistanceKM = iif(isnotnull(HaversineC), 6371.0 * HaversineC, real(null)),\n    DistanceMI = iif(isnotnull(HaversineC), 3958.8 * HaversineC, real(null))\n\n// Extend #5: Speed using Distance\n| extend\n    SpeedKPH = iif(DistanceKM > 0 and TimeDiffHours > 0, DistanceKM / TimeDiffHours, real(null)),\n    SpeedMPH = iif(DistanceMI > 0 and TimeDiffHours > 0, DistanceMI / TimeDiffHours, real(null))\n\n// Final output\n| project\n    User,\n    FirstSigninTime = TimeGenerated,\n    FirstCity = City,\n    FirstCountry = Country,\n    FirstIP = IP,\n    FirstSource = SourceType,\n    FirstLatitude = Latitude,\n    FirstLongitude = Longitude,\n    SecondSigninTime = TimeGenerated1,\n    SecondCity = City1,\n    SecondCountry = Country1,\n    SecondIP = IP1,\n    SecondSource = SourceType1,\n    SecondLatitude = Latitude1,\n    SecondLongitude = Longitude1,\n    TimeDiffHours,\n    DistanceKM,\n    DistanceMI,\n    SpeedKPH,\n    SpeedMPH\n// Uncomment to only return high-speed logins\n// | where SpeedMPH > 500\n| order by FirstSigninTime desc"
}
